

# UV 打印机集中控制与追溯系统

## 📖 项目简介

本系统是一个专为工业生产线设计的 **UV 打印机集中控制与质量追溯平台**。它基于成熟的若依（RuoYi）框架进行深度定制开发，旨在解决多设备协同工作、海量数据实时下发、生产过程闭环追溯的核心痛痛点。

系统不仅能管理打印机、扫码枪等多种硬件设备，还能通过高并发的任务调度引擎，实现从数据源到打印执行，再到扫码质检的全流程自动化管理和监控。

最终，本系统将被打包成一个独立的 **桌面应用程序 (.exe)**，内置 Java 后端和 SQLite 数据库，实现一键部署、开箱即用。

-----

## ✨ 功能特性

系统围绕四大核心业务中心构建，形成了一个完整的数据、执行、质检与监控闭环。

### 1\. 📊 数据中心

生产数据的统一管理入口，是所有打印任务的“数据源泉”。

  - **多源接入**: 支持从U盘、TCP、HTTP、MQTT等多种方式接入生产数据。
  - **数据隔离**: 每个“数据池”独立管理一批生产数据，互不干扰。
  - **状态追踪**: 精确追踪每条数据的使用状态（待使用、已使用、已归档）。
  - **自动归档**: 已完成打印的数据会自动归档，确保主数据池的高效运行。

### 2\. 🔌 设备中心

所有物理硬件的“管家”，负责设备的连接、配置与状态监控。

  - **多设备支持**: 统一管理打印机、扫码枪等不同类型的设备。
  - **连接配置**: 支持 TCP/IP 和串口（SERIAL）两种主流工业通信方式的参数配置。
  - **模板管理**: 可为每台设备配置其支持的打印文件模板及内部变量 (`DeviceFileConfig`)。
  - **实时状态**: 实时监控设备在线、打印中、空闲、故障等状态。

### 3\. 🚀 任务中心

系统的**核心引擎与“大脑”**，负责将数据和设备串联起来，高效执行生产任务。

  - **多设备协同**: 支持创建一个任务并指派给多台设备同时执行，系统会自动进行任务分配。
  - **高并发调度**: 采用\*\*“调度中心 + 生产者-消费者”\*\*的先进架构模式，轻松应对每秒数百条指令的高并发下发场景。
      - **`TaskDispatcherService`**: 任务的“大脑”，负责状态管理和线程协调。
      - **`DataPoolProducerRunner`**: 数据的“生产者”，在后台持续、批量地将原始数据转换为打印指令。
      - **`CommandSenderRunner`**: 指令的“消费者”，负责从指令队列中取出指令并智能地发送给设备。
  - **实时闭环控制**: 通过监听设备返回的完成信号 (`system:2`) 来触发下一条数据的下发，形成精确的实时数据流闭环。

### 4\. ✅ 质检中心

产品的“防火墙”，负责对已打印产品进行质量校验，确保生产合格率。

  - **打印-质检联动**: 产品打印成功后，会自动在质检中心创建一条“待检”记录。
  - **异步自动校验**: 质检工位的扫码枪扫描产品后，系统通过唯一ID自动与打印记录进行匹配和校验。
  - **异常数据处理**: 对于超时未扫码或校验失败的产品，会进入异常列表，支持操作员进行“手动回收”。
  - **数据回收闭环**: 被回收的数据会自动返回其来源的数据池，以便进行重新打印，杜绝物料浪费。

### 5\. 📝 系统日志

  - **多维度日志**: 系统内置了打印记录、扫码记录、通讯记录和系统日志四种维度的日志。
  - **业务关联**: 日志信息与任务、设备、数据池等业务实体深度关联，方便快速筛选和问题定位。
  - **历史快照**: 日志采用“宽表”模式，直接存储关联实体的名称快照，确保了日志的历史真实性，并极大地提升了查询性能。

-----

## 🏗️ 系统架构

1.  **后端**: 基于 **Spring Boot** 和**若依**框架，提供了稳定可靠的基础服务和权限管理。
2.  **通信层**: 采用 **Netty** 构建高性能 TCP 服务器，用于和所有硬件设备进行长连接通信，保证了低延迟和高吞吐量。
3.  **数据库**: 使用 **SQLite** 作为嵌入式数据库，所有数据（包括配置、业务数据、日志）都存储在单个数据库文件中，极大地方便了部署和迁移。
4.  **任务核心**: 基于 `ThreadPoolTaskExecutor` 实现的**生产者-消费者**任务调度模型，将数据I/O和网络I/O彻底解耦，是系统高性能的核心。
5.  **最终形态**: 通过 **Electron** 进行跨平台打包，将整个后端服务（Java Jar）和前端界面封装成一个独立的 **`.exe` 安装包**。在生产环境下，Electron主进程会唤起Java子进程，并通过 **Stdio (标准输入/输出)** 进行高效的内部进程通信。

-----

## 🛠️ 技术选型

  - **核心框架**: Spring Boot 2.5.15
  - **网络通信**: Netty 4.1.79.Final
  - **数据库**: SQLite (via xerial/sqlite-jdbc)
  - **持久层**: MyBatis 3.5.10
  - **桌面打包**: Electron

-----

## 🚀 快速开始

### 1\. 环境要求

  - JDK \>= 1.8
  - Maven \>= 3.0

### 2\. 开发环境运行

1.  **导入项目**: 使用 IntelliJ IDEA 或 Eclipse 导入项目，选择 Maven 项目。
2.  **数据库初始化**: 项目首次启动时，会自动处理数据库文件。初始的数据库文件位于 `ruoyi-admin/src/main/resources/db/app.db`。
3.  **启动后端**: 运行 `ruoyi-admin` 模块下的 `RuoYiApplication.java` 类的 `main` 方法。
4.  **启动前端**: （假设您有配套的前端项目）进入前端项目目录，运行 `npm install && npm run dev`。
5.  **访问**: 后端服务默认启动在 `8080` 端口，Netty 服务器默认监听 `8050` 端口。

-----

## 📦 生产环境部署 (打包成.exe)

本项目的最终交付形态是一个集成了前后端的桌面应用。

### 1\. 后端打包

在项目根目录下，执行 Maven 打包命令：

```bash
mvn clean package
```

这将在 `ruoyi-admin/target` 目录下生成可执行的 `ruoyi-admin.jar` 文件。

### 2\. Electron 打包

1.  **准备文件**:

      * 创建一个 Electron 项目。
      * 在 Electron 项目根目录下，创建一个 `java-backend` 文件夹。
      * 将上面生成的 `ruoyi-admin.jar` 复制到 `java-backend` 文件夹中。

2.  **配置 Electron**:

      * 确保 Electron 的主进程文件 (`main.js`) 中包含了启动 Java 子进程的逻辑，并通过 Stdio 进行通信。
      * 在 `package.json` 中使用 `electron-builder` 的 `extraResources` 配置，将 `java-backend` 文件夹打包进最终的应用中。

3.  **处理 SQLite 数据库**:

      * Java后端已包含智能处理逻辑。在 `.exe` 程序首次启动时，它会自动检查用户目录（例如 `C:\Users\YourUser\AppData\Roaming\UVControlSystem`）是否存在数据库文件。
      * 如果不存在，它会将 `jar` 包内置的初始 `app.db` **复制**到该用户目录下。
      * 之后的所有数据库操作都将发生在这个**外部**的、可持久化的数据库文件上，确保了程序更新不影响用户数据。

4.  **执行打包**:
    在 Electron 项目根目录下运行打包命令：

    ```bash
    npm run pack
    ```

    打包成功后，即可在 `dist` 目录中找到最终的 `.exe` 安装程序。